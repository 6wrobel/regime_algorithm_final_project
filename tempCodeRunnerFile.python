import pandas as pd
import numpy as np
import yfinance as yf
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import backtrader as bt

##########################################
# 1. Data Download and Preprocessing
##########################################
def download_data(symbol, start='2015-01-01', end='2021-01-01'):
    """
    Download historical data from Yahoo Finance using yfinance.
    """
    df = yf.download(symbol, start=start, end=end)
    df.dropna(inplace=True)
    return df

def compute_features(df):
    """
    Compute technical indicators and return a new DataFrame with features.
    """
    feature_df = pd.DataFrame(index=df.index)
    
    # Example features
    feature_df['returns'] = df['Adj Close'].pct_change()
    feature_df['volatility'] = feature_df['returns'].rolling(window=20).std()
    feature_df['ma_fast'] = df['Adj Close'].rolling(window=10).mean()
    feature_df['ma_slow'] = df['Adj Close'].rolling(window=50).mean()
    feature_df['ma_diff'] = feature_df['ma_fast'] - feature_df['ma_slow']  # measure of trend
    feature_df['rsi'] = compute_rsi(df['Adj Close'], window=14)
    
    # Shift or fill to handle NaN
    feature_df.fillna(method='bfill', inplace=True)
    return feature_df

def compute_rsi(series, window=14):
    """
    Helper function to compute RSI. 
    """
    delta = series.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    
    rs = gain / (loss + 1e-10)  # small epsilon to avoid division by zero
    rsi = 100 - (100 / (1 + rs))
    return rsi

##########################################
# 2. Regime Detection with KMeans
##########################################
def detect_regimes(feature_df, n_clusters=3):
    """
    Detect regimes using KMeans clustering.
    For example, we might interpret:
     - Cluster 0 as Bull
     - Cluster 1 as Bear
     - Cluster 2 as Sideways
    """
    # Select features for regime detection. 
    # Adjust features as you see fit for the clustering.
    columns_for_clustering = ['returns', 'volatility', 'ma_diff']
    
    X = feature_df[columns_for_clustering].values
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    
    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
    regimes = kmeans.fit_predict(X_scaled)
    
    feature_df['regime'] = regimes
    return feature_df

##########################################
# 3. Backtrader Strategy Implementation
##########################################
class RegimeBasedStrategy(bt.Strategy):
    params = (
        ('printlog', False),
    )
    
    def log(self, txt, dt=None):
        """ Logging function """
        if self.params.printlog:
            dt = dt or self.datas[0].datetime.date(0)
            print(f'{dt}, {txt}')
    
    def __init__(self):
        # Access the additional data fields
        self.regime = self.datas[0].regime
        self.ma_diff = self.datas[0].ma_diff
        self.rsi = self.datas[0].rsi
        # Additional indicators or references can be added similarly

        # Keep track of orders
        self.order = None
        
    def next(self):
        # If an order is pending, do nothing
        if self.order:
            return
        
        # Check the current regime
        current_regime = int(self.regime[0])
        
        # Example trade logic based on regime:
        # 0 -> Bull, 1 -> Bear, 2 -> Sideways
        if current_regime == 0:
            # Bullish Strategy: If ma_diff > 0 and RSI < 70, go long
            if self.ma_diff[0] > 0 and self.rsi[0] < 70:
                if not self.position:
                    self.order = self.buy()
            elif self.ma_diff[0] < 0 or self.rsi[0] > 70:
                if self.position.size > 0:
                    self.order = self.close()
                    
        elif current_regime == 1:
            # Bearish Strategy: If ma_diff < 0 or RSI > 70, short
            # In backtrader, you can short by using self.sell() if you have no position, 
            # or by reversing your position from long to short.
            if self.ma_diff[0] < 0 and self.rsi[0] > 30:
                if not self.position:
                    self.order = self.sell()
            elif self.ma_diff[0] > 0 or self.rsi[0] < 30:
                if self.position.size < 0:
                    self.order = self.close()
                    
        else:
            # Sideways Strategy: Possibly no trades or some mean reversion approach
            # For demonstration, weâ€™ll close any open positions
            if self.position:
                self.order = self.close()
    
    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Order is active but not yet executed
            return
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(f'BUY EXECUTED, Price: {order.executed.price}')
            else:  # Sell
                self.log(f'SELL EXECUTED, Price: {order.executed.price}')
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('Order Canceled/Margin/Rejected')
        
        # Reset the order
        self.order = None

##########################################
# 4. Putting It All Together: Main Flow
##########################################
if __name__ == '__main__':
    symbol = 'AAPL'
    df = download_data(symbol, start='2018-01-01', end='2021-01-01')
    
    # Compute features
    feature_df = compute_features(df)
    
    # Detect regimes
    feature_df = detect_regimes(feature_df, n_clusters=3)
    
    # Combine feature_df with price data for backtrader
    # backtrader requires a specific format, so we integrate columns properly
    # For simplicity, let's just copy columns into the original DataFrame.
    df['regime'] = feature_df['regime']
    df['ma_diff'] = feature_df['ma_diff']
    df['rsi'] = feature_df['rsi']
    
    # backtrader feed:
    data_feed = bt.feeds.PandasData(
        dataname=df,
        open='Open', high='High', low='Low', close='Close', volume='Volume', openinterest=None,
        timeframe=bt.TimeFrame.Days
    )
    
    # Initialize Cerebro
    cerebro = bt.Cerebro()
    cerebro.adddata(data_feed)
    cerebro.addstrategy(RegimeBasedStrategy, printlog=True)
    
    # Set initial capital
    cerebro.broker.setcash(100000.0)
    
    # Run backtest
    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())
    results = cerebro.run()
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())
    
    # Plot results
    cerebro.plot()
